# SQL-Theory

## 1.	Что такое SQL?
Язык структурированных запросов (SQL) – это язык программирования для хранения и обработки информации в реляционной базе данных. Реляционная база данных хранит информацию в табличной форме со строками и столбцами, представляющими различные атрибуты данных и различные связи между значениями данных. Инструкции SQL можно использовать для хранения, обновления, удаления, поиска и извлечения информации из базы данных. Можно также использовать SQL для поддержания и оптимизации производительности базы данных.
### Все SQL-команды делятся на четыре вида:
* DDL (Data Definition Language, или язык описания данных). Их используют, чтобы создавать, изменять и удалять целые таблицы.
* DML (Data Manipulation Language, или язык управления данными). Их применяют к содержимому таблиц, чтобы создавать, изменять, удалять атрибуты и записи. Если нужно получить какую-то информацию из базы данных, то пользуются именно DML-операторами.
* DCL (Data Control Language, или язык контроля данных). Они нужны, чтобы выдавать конкретным пользователям доступ к базам данных и отзывать его.
* TCL (Transaction Control Language, или язык контроля транзакций). Позволяет управлять транзакциями. Транзакция — это набор из нескольких команд, которые выполняются поочерёдно. Если одна из команд внутри транзакции не срабатывает, то все уже совершённые действия отменяются. То есть транзакция может быть совершена либо полностью, либо никак.
## 2.	Что такое БД?
База данных (БД) — это набор структурированных данных, предназначенный для хранения, обработки и изменения большого количества информации.
### Свойства базы данных
* У БД обязательно должно быть имя.
* БД может быть доступна только для чтения: пользователи считывают данные, но не могут изменять их или объекты БД.
* БД может выводить свое текущее состояние, которое нельзя отредактировать.
* Для БД можно включить шифрование и ограничить доступ.
* БД может фиксировать состояние объектов и их отношений в заданный момент времени.
* БД постоянна: данные безостановочно накапливаются и используются.
* БД подстраивается под новые данные и актуализируется.

## 3.	Какие бываю БД?
### Иерархические
Имеют древовидную схему, в которой корень (единый ствол) порождает множество расходящихся ветвей. Данные структурируются отношением «родитель-потомок». Примером иерархической базы служат файлы в вашем компьютере. Имеется основной диск, в котором лежат папки, содержащие другие папки. Физическая связь возможна путем взаимодействия с предыдущей папкой.
### Сетевые
В отличие от иерархической структуры у каждой записи может быть больше одного родителя. Используется не древовидная схема, а общий граф. Сетевой тип БД делит данные на два типа: узлы и ребра. Узлами называются объекты, а ребрами — связи между ними и их направления.
### Объектно-ориентированные
Расширение традиционных реляционных баз данных, в котором данные хранятся и обрабатываются в виде объектов. Объекты могут содержать также методы работы с данными, благодаря этому с данными можно работать эффективнее.
### Реляционные
Наиболее распространенный тип БД, где данные организованы в таблицах, а отношения между ними определяются с помощью ключей. В каждом столбце таблицы указывается атрибут объекта, о котором идет речь. Это может быть имя пользователя, род деятельности. Конкретный атрибут или комбинация атрибутов выбираются в качестве первичного ключа. Когда на ключ ссылаются другие таблицы, то он называется внешним ключом.

Реляционные БД поддерживают как модель «один ко многим», так и «многие ко многим».

#### Основные принципы реляционных БД:
* Все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов.
* В пересечение строки и столбца таблицы можно занести только одно значение.
* Все операции выполняются над целыми отношениями, и результатом этих операций является отношение.

Реляционные базы могут быть организованы по строкам или столбцам, что влияет на их оптимальное использование в различных сценариях: учет персонала и товаров, ведение бухгалтерии и электронного документооборота.

### Нереляционные (NoSQL)
Способны обрабатывать неструктурированные данные. Применяют несколько моделей в зависимости от типа обрабатываемых данных.

Нереляционные базы отлично подходят для обработки неструктурированных или полуструктурированных данных.

## 4.	В каком виде хранятся данные в Реляционных БД?
Реляционная база данных — это тип базы данных, в которой данные организованы в таблицы, и эти таблицы связаны на основе данных, общих для каждой из них. Эта структура позволяет выполнять гибкие сложные запросы одновременно ко многим таблицам.

### Структура реляционной базы данных
Реляционная база данных состоит из нескольких ключевых компонентов:
* таблицы. Это строительные блоки реляционной базы данных. Каждая таблица содержит данные об определенном объекте, таком как клиенты или продукты;
* поля. Это различные категории данных в каждой таблице, такие как «имя» или «электронная почта»;
* записи. Это отдельные записи в таблице. Каждая запись включает уникальный ключ, известный как первичный ключ, который идентифицирует эту запись;
* отношения. Это связи между таблицами, установленные с помощью общих данных, известных как внешние ключи.

## 5.	Что такое СУБД
Систе́ма управле́ния ба́зами да́нных (СУБД; англ. Database Management System), комплекс программ, которая позволяет создать базу данных (БД) и управлять данными (вставлять, обновлять, удалять и выбирать). Обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД.

Она позволяет упростить и автоматизировать процессы управления информацией, обеспечить ее безопасность и доступность в нужный момент.

СУБД позволяют пользователям создавать базы данных, определять структуру данных, взаимодействовать с данными через запросы и обеспечивать защиту информации. Они обеспечивают множество функций, таких как поддержка транзакций, согласованность данных, управление соединениями, оптимизация запросов и многое другое.

## 6.	Какие ты знаешь СУБД?
* Реляционные СУБД, такие как MySQL, Oracle, PostgreSQL и др., обычно используются для хранения структурированных данных в виде таблицы с реляционными связями. Они обеспечивают эффективное хранение, поиск и обновление данных.
* Нереляционные СУБД, такие как MongoDB, Cassandra, Redis и др., предназначены для хранения и обработки неструктурированных данных, таких как документы, графы, ключ-значение и другие. Они обычно быстрее и масштабируемее, чем реляционные СУБД.
* Временные СУБД используются для хранения и обработки временных данных, таких как журналы событий, временные серии данных и другие временные данные.
* Распределенные СУБД обеспечивают возможность хранить данные на нескольких физических серверах и выполнять параллельную обработку запросов. Это позволяет повысить производительность и масштабируемость системы.
* Встраиваемые СУБД, такие как SQLite или Berkley DB, используются для встроенного хранения данных в приложениях, не требуя установки дополнительного программного обеспечения или сервера базы данных. В целом, выбор определенного вида СУБД * * зависит от требований к производительности, масштабируемости, доступности данных, структуры данных и других факторов.
* Объектно-ориентированные СУБД: поддерживают хранение и обработку объектов, включая методы и атрибуты.
* Многомерные СУБД: используются для анализа данных с разных точек зрения.
* Графовые СУБД: основаны на графах, где данные представлены в виде узлов и связей между ними.

## 7.	Какая разница между MySQL и SQL?
SQL – это язык программирования, который можно использовать для запроса и обработки информации в реляционной базе данных, а также для добавления, обновления или извлечения данных в базе данных. В 1986 году Американский национальный институт стандартов присвоил SQL статус официального стандарта для реляционных баз данных. В 1987 году его примеру последовала Международная организация по стандартизации.

MySQL, в свою очередь, – это система управления реляционными базами данных. Вы можете использовать MySQL для хранения данных и управления ими с помощью таблиц в качестве системы управления реляционными базами данных. Можно создавать таблицы и определять отношения между ними. Вы также можете применять несколько методов, таких как индексы, транзакции и нормализация, для хранения и извлечения данных, сохраняя при этом их единообразие и точность. 

## 8.	Что такое первичный ключ (Primary key)?
Подробно Что такое первичный ключ (Primary key)
Первичный ключ (Primary Key) — это фундаментальное понятие в реляционных базах данных, которое играет ключевую роль в обеспечении уникальности и целостности данных в таблице. Вот подробное объяснение:

### Основные характеристики первичного ключа:
#### Уникальность:
Каждое значение в столбце первичного ключа должно быть уникальным. Это означает, что в таблице не может быть двух строк с одинаковым значением первичного ключа. Это гарантирует, что каждая запись в таблице будет однозначно идентифицирована.
#### Не допускает NULL значений:
Значение первичного ключа не может быть NULL. Каждая запись должна иметь конкретное значение в столбце первичного ключа.
#### Единственность:
В каждой таблице может быть только один первичный ключ, но он может состоять из одного или нескольких столбцов (составной ключ).
### Примеры использования первичного ключа:
##### Простой первичный ключ:
Один столбец используется в качестве уникального идентификатора.

    CREATE TABLE users (
      id INT PRIMARY KEY,
      name VARCHAR(100),
      email VARCHAR(100)
    );
В этом примере id является первичным ключом таблицы users.
##### Составной первичный ключ:
Несколько столбцов вместе образуют уникальный идентификатор.

    CREATE TABLE orders (
      order_id INT,
      product_id INT,
      PRIMARY KEY (order_id, product_id)
    );
В этом примере комбинация order_id и product_id образует составной первичный ключ таблицы orders.
### Зачем нужен первичный ключ:
#### Идентификация записей:
Уникально идентифицирует каждую запись в таблице, что облегчает поиск, обновление и удаление данных.
#### Обеспечение целостности данных:
Гарантирует, что каждая запись уникальна и нет дублирующихся данных.
#### Связи между таблицами:
Используется для создания связей между таблицами через внешние ключи (FOREIGN KEY). Внешний ключ в одной таблице ссылается на первичный ключ в другой таблице.
### Пример связи между таблицами с использованием первичного и внешнего ключа:
Таблица departments:

    CREATE TABLE departments (
      department_id INT PRIMARY KEY,
      department_name VARCHAR(50)
    );
Таблица employees:

    CREATE TABLE employees (
      employee_id INT PRIMARY KEY,
      first_name VARCHAR(50),
      last_name VARCHAR(50),
      department_id INT,
      FOREIGN KEY (department_id) REFERENCES departments(department_id)
    );
В этом примере department_id является первичным ключом в таблице departments и внешним ключом в таблице employees. Это позволяет создать связь между таблицами и обеспечить целостность данных.

## 9.	Что такое внешний ключ (Foreign key)?
Внешний ключ (Foreign Key) — это столбец или набор столбцов в одной таблице, который указывает на первичный ключ в другой таблице. Внешний ключ используется для установления и обеспечения ссылочной целостности между двумя таблицами, связывая их на уровне данных.
### Основные характеристики внешнего ключа:
#### Ссылочная целостность:
* Внешний ключ гарантирует, что значения в одной таблице соответствуют значениям в другой таблице.
* Он обеспечивает целостность данных, гарантируя, что каждая запись в дочерней таблице имеет соответствующую запись в родительской таблице.
#### Связи между таблицами:
* Внешний ключ устанавливает отношения между таблицами, такие как "один ко многим" и "многие ко многим".
* Пример: Связь между таблицами students и enrollments, где каждая запись в таблице enrollments ссылается на запись в таблице students.
### Пример внешнего ключа:
#### Создание таблиц с внешним ключом:
В этом примере мы создаем таблицу departments с первичным ключом и таблицу employees, которая имеет внешний ключ, указывающий на departments.

    CREATE TABLE departments (
      department_id INT PRIMARY KEY,
      department_name VARCHAR(50)
    );

    CREATE TABLE employees (
      employee_id INT PRIMARY KEY,
      first_name VARCHAR(50),
      last_name VARCHAR(50),
      department_id INT,
      FOREIGN KEY (department_id) REFERENCES departments(department_id)
    );
#### Добавление внешнего ключа в существующую таблицу:
Если таблица уже существует, можно добавить внешний ключ с помощью команды ALTER TABLE.

    ALTER TABLE employees
    ADD CONSTRAINT fk_department
    FOREIGN KEY (department_id)
    REFERENCES departments(department_id);
#### Примеры использования внешнего ключа:
##### Связь "один к одному":
* Каждой записи в первой таблице соответствует одна запись во второй таблице.
* Пример: Таблица person и таблица passport, где у каждого человека только один паспорт и у каждого паспорта только один владелец.
##### Связь "один ко многим":
* Каждой записи в первой таблице соответствует несколько записей во второй таблице.
* Пример: Таблица department и таблица employees, где каждый департамент может иметь много сотрудников.
##### Связь "многие ко многим":
* Каждой записи в первой таблице может соответствовать несколько записей во второй таблице, и наоборот.
* Пример: Таблицы students, courses и промежуточная таблица enrollments для хранения информации о том, какие студенты записаны на какие курсы.

      CREATE TABLE students (
        student_id INT PRIMARY KEY,
        student_name VARCHAR(50)
      );

      CREATE TABLE courses (
        course_id INT PRIMARY KEY,
        course_name VARCHAR(50)
      );

      CREATE TABLE enrollments (
        student_id INT,
        course_id INT,
        PRIMARY KEY (student_id, course_id),
        FOREIGN KEY (student_id) REFERENCES students(student_id),
        FOREIGN KEY (course_id) REFERENCES courses(course_id)
      );
### Зачем нужен внешний ключ:
#### Обеспечение целостности данных:
Внешний ключ гарантирует, что данные остаются согласованными между связанными таблицами. Например, нельзя добавить запись в дочернюю таблицу, если соответствующая запись отсутствует в родительской таблице.
#### Поддержание связей:
Внешний ключ позволяет управлять и поддерживать связи между различными таблицами в базе данных, облегчая навигацию и работу с данными.
#### Упрощение выполнения запросов:
Внешний ключ позволяет легко выполнять запросы, которые объединяют данные из связанных таблиц.

## 10.	Что такое реляции?
Реляции (или отношения) — это фундаментальная концепция реляционных баз данных, где данные организованы и управляются в виде таблиц. Эти таблицы состоят из строк и столбцов, и каждая строка представляет собой отдельную запись данных, а каждый столбец представляет собой атрибут данных. Давай углубимся в эту концепцию.
### Основные элементы реляционных баз данных:
#### Таблицы:
Таблицы — это основные структуры для хранения данных. В каждой таблице содержится информация об одном типе сущностей.
#### Столбцы (Атрибуты):
Атрибуты — это свойства или характеристики данных, хранящихся в таблице. Каждый атрибут соответствует столбцу таблицы.
#### Строки (Записи):
Каждая строка в таблице представляет собой отдельную запись данных. Эти записи часто называют туплами.
### Связи между реляциями:
Реляционные базы данных используют связи между таблицами для организации данных. Эти связи могут быть следующих типов:
#### Связь "один к одному" (1:1):
Каждой записи в одной таблице соответствует одна запись в другой таблице.
#### Связь "один ко многим" (1:N):
Каждой записи в первой таблице соответствует несколько записей во второй таблице.
#### Связь "многие ко многим" (M:N):
Каждой записи в первой таблице может соответствовать несколько записей во второй таблице, и наоборот.

## 11.	Зачем нужны реляции? приведи пример реляции как она вообще работает?
Реляции (или отношения) в реляционных базах данных (РБД) необходимы для структурирования и упорядочивания данных, а также для установления взаимосвязей между различными таблицами. Они обеспечивают целостность и согласованность данных, позволяют выполнять сложные запросы и анализировать информацию.
### Зачем нужны реляции:
#### Целостность данных:
Реляции обеспечивают целостность данных, гарантируя, что данные между связанными таблицами остаются согласованными. Например, нельзя добавить запись в дочернюю таблицу, если соответствующая запись отсутствует в родительской таблице.
#### Логическая организация:
Реляции позволяют логически организовать данные, разбивая информацию на отдельные таблицы, которые связаны между собой. Это делает данные более управляемыми и легче для понимания.
#### Эффективность запросов:
Реляции упрощают выполнение сложных запросов, которые объединяют данные из нескольких таблиц, позволяя легко анализировать и манипулировать данными.
### Типы связей между реляциями:
#### Связь "один к одному" (1:1):
* Каждой записи в одной таблице соответствует одна запись в другой таблице.
* Пример: Таблица passport и таблица person, где у каждого человека только один паспорт и у каждого паспорта только один владелец.

        CREATE TABLE person (
          person_id INT PRIMARY KEY,
          name VARCHAR(100)
        );

        CREATE TABLE passport (
          passport_id INT PRIMARY KEY,
          person_id INT,
          FOREIGN KEY (person_id) REFERENCES person(person_id)
        );
#### Связь "один ко многим" (1:N):
* Каждой записи в первой таблице соответствует несколько записей во второй таблице.
* Пример: Таблица department и таблица employees, где каждый департамент может иметь много сотрудников.

        CREATE TABLE department (
          department_id INT PRIMARY KEY,
          department_name VARCHAR(50)
        );

        CREATE TABLE employees (
          employee_id INT PRIMARY KEY,
          first_name VARCHAR(50),
          last_name VARCHAR(50),
          department_id INT,
          FOREIGN KEY (department_id) REFERENCES department(department_id)
        );
#### Связь "многие ко многим" (M:N):
* Каждой записи в первой таблице может соответствовать несколько записей во второй таблице, и наоборот.
* Пример: Таблицы students, courses и промежуточная таблица enrollments для хранения информации о том, какие студенты записаны на какие курсы.

        CREATE TABLE students (
          student_id INT PRIMARY KEY,
          student_name VARCHAR(50)
        );
        
        CREATE TABLE courses (
          course_id INT PRIMARY KEY,
          course_name VARCHAR(50)
        );
        
        CREATE TABLE enrollments (
          student_id INT,
          course_id INT,
          PRIMARY KEY (student_id, course_id),
          FOREIGN KEY (student_id) REFERENCES students(student_id),
          FOREIGN KEY (course_id) REFERENCES courses(course_id)
        );

## 12.	Что такое соединения в SQL?
Join — это операции, которые позволяют объединять строки из двух или более таблиц на основе логической связи между ними. Это позволяет извлекать связанные данные из разных таблиц в одном запросе.


## 13.	Какие ты  знаешь JOIN?
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfD-jXPCv_eyET49SS_Ljc3IDy8DTTSCA7_4GbGtAfnzQRim2g-AbmsP9B_jroaCHWdXbg7ciw1ABmmtqlk34flraZ7-0APQ9surGKlHseVJG6jnJC0CzWGOp389zI7gOVTwnqKYYP05Bb_YG0ZDQZaxJwvso59roxEVYRhl18IsiY9jfIAEg?key=e0vsqrxBogS9Vk79SX7BEQ)

### INNER JOIN:
Возвращает строки, которые имеют совпадения в обеих таблицах.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    INNER JOIN enrollments ON students.student_id = enrollments.student_id
    INNER JOIN courses ON enrollments.course_id = courses.course_id;
### LEFT JOIN (или LEFT OUTER JOIN):
Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадения нет, возвращаются NULL значения для правой таблицы.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    LEFT JOIN enrollments ON students.student_id = enrollments.student_id
    LEFT JOIN courses ON enrollments.course_id = courses.course_id;
### RIGHT JOIN (или RIGHT OUTER JOIN):
Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадения нет, возвращаются NULL значения для левой таблицы.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    RIGHT JOIN enrollments ON students.student_id = enrollments.student_id
    RIGHT JOIN courses ON enrollments.course_id = courses.course_id;
### FULL JOIN (или FULL OUTER JOIN):
Возвращает строки, которые имеют совпадения в одной из таблиц или обеих. Несовпадающие строки заполняются NULL значениями.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    FULL JOIN enrollments ON students.student_id = enrollments.student_id
    FULL JOIN courses ON enrollments.course_id = courses.course_id;
### CROSS JOIN:
Возвращает декартово произведение строк из обеих таблиц, то есть каждая строка одной таблицы объединяется с каждой строкой другой таблицы.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    CROSS JOIN courses;
    SELF JOIN:

### Соединение таблицы с самой собой для извлечения связанных данных из одной таблицы.
#### 📌Пример:

    SELECT a.name AS name1, b.name AS name2
    FROM employees a, employees b
    WHERE a.manager_id = b.employee_id;

## 14.	Расскажи подробно про FULL JOIN
FULL JOIN, или FULL OUTER JOIN, в SQL объединяет строки из двух таблиц и возвращает все строки, которые имеют совпадения в одной из таблиц или в обеих. Несовпадающие строки заполняются значениями NULL в тех местах, где нет совпадений. Это соединение полезно, когда нужно извлечь все данные, даже если некоторые строки не имеют соответствий.
### Основные характеристики FULL JOIN:
#### Объединение всех данных:
Возвращает все строки из обеих таблиц, независимо от наличия соответствий.
#### Заполнение NULL значениями:
Если для строки одной таблицы нет соответствующей строки в другой таблице, NULL значения заполняются для отсутствующих столбцов.
### 📌Пример использования FULL JOIN:
Предположим, у нас есть две таблицы: students (студенты) и courses (курсы).

    Таблица students:
    student_id | name
    -----------|---------
    1          | John
    2          | Jane
    3          | Alice

    Таблица courses:
    course_id | student_id | course_name
    ----------|------------|-------------
    101       | 1          | Math
    102       | 2          | Physics
    103       | 4          | Chemistry

    Запрос с использованием FULL JOIN:
    SELECT students.student_id, students.name, courses.course_name
    FROM students
    FULL JOIN courses ON students.student_id = courses.student_id;

    Результат:
    student_id | name  | course_name
    -----------|-------|-------------
    1          | John  | Math
    2          | Jane  | Physics
    3          | Alice | NULL
    NULL       | NULL  | Chemistry
### Что происходит в этом запросе:
* John и Jane имеют соответствия в обеих таблицах, поэтому они возвращаются с именами курсов.
* Alice не имеет соответствия в таблице courses, поэтому её строка заполняется NULL значением для столбца course_name.
* Chemistry не имеет соответствия в таблице students, поэтому её строка заполняется NULL значениями для столбцов student_id и name.

### Практическое применение FULL JOIN:
* FULL JOIN полезен, когда нужно собрать полный набор данных из двух таблиц, независимо от наличия соответствий. Например:
* Анализировать полный список студентов и курсов, чтобы найти несоответствия.
* Собрать данные из нескольких источников, где некоторые записи могут отсутствовать в одной из таблиц.

## 15.	Что такое Union?
![](https://www.boardinfinity.com/blog/content/images/2022/12/Your-paragraph-text--6-.jpg)
UNION — это оператор в SQL, используемый для объединения результатов двух или более SELECT-запросов в один итоговый набор данных. UNION позволяет комбинировать данные из разных таблиц или запросов, предоставляя возможность анализа и манипуляции с объединёнными данными.
### Основные характеристики UNION:
#### Объединение результатов:
UNION объединяет результаты двух или более запросов и возвращает уникальные строки. При этом дублирующиеся строки удаляются. Для сохранения всех строк, включая дублирующиеся, используется UNION ALL.
#### Количество столбцов:
Все запросы, объединенные через UNION, должны возвращать одинаковое количество столбцов. Столбцы должны быть совместимы по типу данных.
#### Порядок столбцов:
Порядок столбцов в каждом SELECT-запросе должен совпадать.

### Синтаксис UNION:

    SELECT column1, column2, ...
    FROM table1
    UNION
    SELECT column1, column2, ...
    FROM table2;

## 16.	В чем разница между UNION и UNION ALL ?
### Отличия UNION и UNION ALL:
#### UNION:
* Возвращает только уникальные строки.
* Убирает дубликаты.
#### UNION ALL:
* Возвращает все строки, включая дублирующиеся.
* Не удаляет дубликаты.

## 17.	Что такое SELECT ?
SELECT SQL — оператор запроса, который возвращающает определённый набор данных из базы данных. Список столбцов выборки задаётся в части оператора, которая называется предложением оператора SELECT.
### Синтаксис SELECT SQL

    SELECT column1, column2, ...
    FROM table_name;

## 18.	Что такое подзапрос?
Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.
### Как и любой другой SQL запрос, подзапрос возвращает результирующий набор, который может быть одним из следующих:
* одна строка и один столбец;
* нескольких строк с одним столбцом;
* нескольких строк с несколькими столбцами.

В зависимости от типа результирующего набора подзапроса определяются операторы, которые могут использоваться в основном запросе.
#### 📌Пример
Получим список всех бронирований самого дорогого на данный момент жилого помещения:

    SELECT * FROM Reservations
        WHERE Reservations.room_id = (
            SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
        )
В данном случае запрос на получение самого дорогого жилого помещения выполняется в качестве подзапроса, а затем результат результирующего набора применяется в основном запросе.

## 19.	Какая очередность выполнения когда есть подзапрос? что первым выполняется?
В SQL, когда выполняется запрос, содержащий подзапрос, существует определенная последовательность выполнения. Подзапрос (или вложенный запрос) сначала выполняется, а затем его результаты используются в основном запросе.

## 20.	Какие ограничения существуют при создании таблиц?
Ограничение (constraints) — это ограничение типа значений, которое накладывается на один или несколько столбцов таблицы. Это позволяет поддерживать точность и целостность данных в таблице БД.
### Ограничение NOT NULL
Ограничение NOT NULL указывает, что столбец не может принимать значения NULL.
Если к столбцу применено ограничение NOT NULL, вы не сможете вставить новую строку в таблицу без добавления не-NULL-значения в этот столбец.
### Ограниение PRIMARY KEY
Ограничение PRIMARY KEY определяет столбец или набор столбцов, значения которых однозначно идентифицируют строку в таблице. То есть никакие две строки в таблице не могут иметь одинаковое значение первичного ключа. Также нельзя вводить значение NULL в столбец первичного ключа.
### Ограничение UNIQUE
Ограничение UNIQUE означает, что в указанных столбцах обязательно должны быть уникальные значения.
Хотя и ограничение UNIQUE, и ограничение PRIMARY KEY обеспечивают уникальность значений, есть различия.
UNIQUE  лучше PRIMARY KEY, когда вы хотите обеспечить уникальность столбца или комбинации столбцов, которые не являются первичным ключом.
### Ограничение DEFAULT
Ограничение DEFAULT определяет значение по умолчанию для столбцов.
Значение столбца по умолчанию — это некоторое значение, которое будет вставлено в столбец базой данных, если оператор INSERT явно не назначит конкретное значение.
### Ограничение FOREIGN KEY
Внешний ключ (foreign key) — это столбец или комбинация столбцов, которые используются для установления и обеспечения взаимосвязи между данными в двух таблицах.
Ниже — диаграмма, которая показывает связь между таблицами сотрудников (employees) и отделов (departments). Если вы внимательно посмотрите на нее, то заметите, что столбец dept_id таблицы сотрудников совпадает со столбцом первичного ключа таблицы отделов. Поэтому столбец dept_id таблицы сотрудников является внешним ключом для таблицы отделов.
### Ограничение CHECK
Ограничение CHECK используется для ограничения значений, которые могут быть помещены в столбец.
Например, диапазон значений для столбца зарплаты salary можно ограничить, создав ограничение CHECK, которое допускает значения только от 30 000 до 100 000. Это предотвратит ввод зарплат за пределами обычного (условного) диапазона. 

## 21.	Что такое Group By
GROUP BY — это оператор SQL, который используется для группировки строк в таблице на основе значений одного или нескольких столбцов. Обычно используется вместе с агрегатными функциями (например, COUNT, SUM, AVG, MAX, MIN) для выполнения операций над группами данных.
### Основные характеристики GROUP BY:
#### Группировка данных:
Группирует строки с одинаковыми значениями в указанных столбцах в одну группу.
#### Агрегация данных:
Позволяет выполнять агрегатные функции над каждой группой данных.
### Синтаксис:

    SELECT column1, aggregate_function(column2)
    FROM table_name
    GROUP

## 22.	Что такое Order by?
## 23.	Что нужно указать что бы было по возрастанию или по убыванию в операторе Order by ?
При выполнении SELECT запроса, строки по умолчанию возвращаются в неопределённом порядке. Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя. Для упорядочивания записей используется конструкция ORDER BY.
### Общая структура запроса с оператором ORDER BY

    SELECT поля_таблиц FROM наименование_таблицы
    WHERE ...
    ORDER BY столбец_1 [ASC | DESC][, столбец_n [ASC | DESC]]
### Где ASC и DESC - направление сортировки:
* ASC - сортировка по возрастанию (по умолчанию)
* DESC - сортировка по убыванию
### Сортировка по нескольким столбцам
Для сортировки результатов по двум или более столбцам их следует указывать через запятую.

Данные будут сортироваться по первому столбцу, но в случае если попадаются несколько записей с совпадающими значениями в первом столбце, то они сортируются по второму столбцу. Количество столбцов, по которым можно отсортировать, не ограничено.

## 24.	Что такое INSERT?
Оператор INSERT в языке SQL используется для добавления новых записей в таблицу базы данных. Он позволяет указать значения для каждого столбца при вставке новой строки данных.
### Синтаксис:

    INSERT INTO table_name (column1, column2, ...)
    VALUES (value1, value2, ...);
### Параметры:
* table_name: Имя таблицы, в которую выполняется вставка данных.
* column1, column2, ...: Список столбцов, в которые будут вставлены значения.
* value1, value2, ...: Список значений, которые соответствуют столбцам таблицы.

## 25.	Что такое Update?
Оператор UPDATE в языке SQL используется для изменения данных в существующих записях таблицы. Он обновляет значения в указанных столбцах для строк, которые соответствуют заданным условиям.
### Синтаксис:
    UPDATE table_name
    SET column1 = value1, column2 = value2, ...
    WHERE condition;
### Параметры:
* table_name: Имя таблицы, в которой производится обновление данных.
* column1 = value1, column2 = value2, ...: Список столбцов и их новых значений.
* condition: Условие, определяющее, какие строки будут обновлены. Если условие не указано, все строки будут обновлены.

## 26.	Какое отличие WHERE и HAVING
### WHERE
Оператор WHERE в языке SQL используется для фильтрации строк в результате запроса. Он позволяет указать условие, которое должно быть выполнено для включения строки в результаты запроса. Оператор WHERE используется в комбинации с операторами SELECT, UPDATE, DELETE и другими для определения условий отбора данных.
#### Синтаксис:
    SELECT column1, column2, ...
    FROM table_name
    WHERE condition;
#### Пример:
Предположим, у нас есть таблица "Students" с информацией о студентах, и мы хотим выбрать только тех студентов, чей возраст меньше 20 лет:

    SELECT StudentID, FirstName, LastName, Age, Department
    FROM Students
    WHERE Age < 20;
В данном запросе оператор WHERE фильтрует строки по условию, что значение в столбце "Age" должно быть меньше 20.
### HAVING
Оператор HAVING в языке SQL применяется после оператора GROUP BY и используется для фильтрации результатов агрегатных функций на основе заданных условий. Он позволяет применять условия к группам строк, сгруппированным по определенному столбцу или столбцам.
#### Синтаксис:
    SELECT column1, aggregate_function(column2)
    FROM table_name
    GROUP BY column1
    HAVING condition;
#### Параметры:
* column1: Столбец, по которому происходит группировка.
* aggregate_function(column2): Агрегатная функция, применяемая к столбцу column2 в каждой группе.
* table_name: Имя таблицы, из которой извлекаются данные.
* condition: Условие, применяемое к результатам агрегации.
#### Пример:
Предположим, у нас есть таблица "Orders" с информацией о заказах и мы хотим найти общее количество заказов для каждого клиента, но отобразить только тех клиентов, у которых количество заказов больше 2:

    SELECT CustomerID, COUNT(OrderID) AS TotalOrders
    FROM Orders
    GROUP BY CustomerID
    HAVING COUNT(OrderID) > 2;

## 27.	Какие знаеш агрегатные функции?
Агрегатная функция выполняет вычисление над набором значений и возвращает одно значение. В табличной модели данных это значит, что функция берет ноль, одну или несколько строк для какой-то колонки и возвращает единственное значение.
### Свойства агрегатных функций:
* Игнорируют NULL-значения. Исключение — функция COUNT(*). Дальше детально рассмотрим, что это значит.
* Все агрегатные функции детерминированы. Это значит, что для одинакового набора данных функции возвращают одинаковое значение.
Агрегатные функции часто используются с операторами GROUP BY и HAVING. Оператор GROUP BY группирует строки с одинаковыми значениями в одну строку. Оператор HAVING используется в качестве фильтра для запросов, в которых есть оператор GROUP BY.

С агрегатными функциями можно использовать ключевые слова DISTINCT и ALL

### Функция COUNT
COUNT считает количество строк в таблице. Она может принимать в качестве параметров как числовые, так и нечисловые типы данных.

COUNT(*) — специальная форма функции COUNT, которая возвращает количество всех строк в указанной таблице. Обратите внимание: COUNT(*) считает дубликат и NULL.

    📌Пример:
    SELECT COUNT(*) FROM employees;

### SUM
Функция SUM вычисляет суммы всех выбранных столбцов. Обратите внимание: она работает только с числовыми полями.

    📌Пример:
    SELECT SUM(salary) FROM employees;

### MAX и MIN
Эти функции нужны для нахождения максимального и минимального значения для определенного столбца.

    📌Пример:
    SELECT MAX(salary) FROM employees;
    📌Пример:
    SELECT MIN(salary) FROM employees;

### AVG
Функция используется для вычисления среднего значения заданного столбца.

    📌Пример:
    SELECT AVG(salary) FROM employees;

### GROUP_CONCAT():
Объединяет значения из множества строк в одну строку с указанным разделителем.

    📌Пример:
    SELECT GROUP_CONCAT(name) FROM employees;

## 28.	Для чего используются операторы IN, BETWEEN, LIKE?
Операторы IN, BETWEEN и LIKE в SQL используются для фильтрации данных, выполняя различные типы сравнений и проверок. Они помогают уточнять запросы и находить нужные данные.
### IN:
* Описание: Проверяет, соответствует ли значение любому значению из указанного списка.
* Применение: Используется для поиска значений в ограниченном диапазоне или множестве значений.

        📌Пример:
        SELECT * FROM employees WHERE department IN ('Sales', 'HR', 'IT');
        Это запрос вернет всех сотрудников, работающих в отделах Sales, HR и IT.

### BETWEEN:
* Описание: Проверяет, находится ли значение в заданном диапазоне (включительно).
* Применение: Используется для проверки, попадают ли значения в определенный диапазон.

        📌Пример:
        SELECT * FROM products WHERE price BETWEEN 100 AND 500;
        Этот запрос вернет все продукты с ценой между 100 и 500 включительно.

### LIKE:
* Описание: Проверяет, соответствуют ли строки указанному шаблону.
* Применение: Используется для поиска строк, соответствующих определенному шаблону с использованием подстановочных знаков.

        📌Пример:
        SELECT * FROM customers WHERE name LIKE 'J%';

## 29.	Какие условия выполнения операторов OR и AND
Операторы OR и AND в SQL используются для комбинирования нескольких условий в одном запросе, определяя, какие строки должны быть возвращены на основе логических связей между этими условиями.
### Оператор AND:
* Описание: Оператор AND используется для того, чтобы объединить два или более условий. Все условия, объединенные оператором AND, должны быть истинны, чтобы строка была включена в результаты.

        📌Пример:
        SELECT * FROM employees
        WHERE department = 'Sales' AND salary > 50000;
        Этот запрос вернет всех сотрудников, работающих в отделе продаж и получающих зарплату более 50,000.
### Оператор OR:
* Описание: Оператор OR используется для объединения двух или более условий. Достаточно, чтобы хотя бы одно из условий было истинным, чтобы строка была включена в результаты.

        📌Пример:
        SELECT * FROM employees
        WHERE department = 'Sales' OR department = 'HR';
        Этот запрос вернет всех сотрудников, работающих в отделах продаж или HR.

### Комбинирование операторов AND и OR:
* Описание: Операторы AND и OR могут использоваться вместе для создания более сложных условий. В таких случаях важно использовать скобки для явного определения приоритета условий.

        📌Пример:
        SELECT * FROM employees
        WHERE (department = 'Sales' OR department = 'HR') AND salary > 50000;
        Этот запрос вернет всех сотрудников, работающих в отделах продаж или HR, получающих зарплату более 50,000.
## 30.	Оператор SQL LIMIT
это оператор SQL, который используется для ограничения количества строк, возвращаемых запросом. Это полезно, когда нужно получить только определенное количество записей из таблицы, особенно в случаях, когда результат может быть очень большим.
### Основные характеристики LIMIT:
#### Ограничение количества строк:
* Позволяет указать максимальное количество строк, которое должно быть возвращено.

        📌Пример:
        SELECT * FROM employees LIMIT 10;
        Этот запрос вернет первые 10 строк из таблицы employees.
### Смещение (OFFSET):
* Совместно с LIMIT можно использовать OFFSET для указания начальной точки выборки.

        📌Пример:
        SELECT * FROM employees LIMIT 10 OFFSET 5;
        Этот запрос вернет 10 строк, начиная с 6-й строки таблицы employees.

## 31.	Чем NULL отличается от 0
### NULL:
* Описание: NULL представляет собой отсутствие значения или неизвестное значение. Это означает, что значение данного поля не установлено или неизвестно.
* Применение: Используется для обозначения неопределённых или отсутствующих данных.
* Сравнения: Любые сравнения с NULL (например, NULL = NULL, NULL < 5) возвращают NULL или FALSE, потому что NULL не является ни истинным, ни ложным.

        📌Пример:
        SELECT * FROM employees WHERE department IS NULL;
        Этот запрос вернет всех сотрудников, у которых значение в столбце department отсутствует.
0:
* Описание: 0 — это конкретное числовое значение, представляющее собой ноль.
* Применение: Используется как числовое значение и имеет математическое значение.
* Сравнения: Любые сравнения с 0 выполняются как обычные числовые сравнения (например, 0 = 0, 0 < 5).

        📌Пример:
        SELECT * FROM employees WHERE salary = 0;
        Этот запрос вернет всех сотрудников, у которых зарплата равна нулю.

## 32.	В чем разница между операторами GROUP BY и DISTINCT?
### DISTINCT:
* Цель: Удаление дубликатов.
* Описание: DISTINCT используется для возврата уникальных строк в наборе результатов.

        📌Пример:
        SELECT DISTINCT department FROM employees;
        Этот запрос вернет уникальные значения столбца department из таблицы employees.
* Когда использовать: Когда нужно получить уникальные значения из одного или нескольких столбцов.
### GROUP BY:
* Цель: Группировка строк на основе значения одного или нескольких столбцов.
* Описание: GROUP BY используется для группировки строк с одинаковыми значениями в указанном столбце и часто применяется вместе с агрегатными функциями (например, COUNT, SUM, AVG) для выполнения операций над каждой группой.

        📌Пример:
        SELECT department, COUNT(*) AS num_employees
        FROM employees
        GROUP BY department;
        Этот запрос вернет количество сотрудников в каждом отделе.
* Когда использовать: Когда нужно выполнить агрегатные функции над группами данных.
### Основные отличия:
#### DISTINCT:
* Удаляет дубликаты и возвращает только уникальные строки.
* Применяется ко всей строке или к отдельным столбцам.
* Не используется с агрегатными функциями.
#### GROUP BY:
* Группирует строки на основе значений одного или нескольких столбцов.
* Часто используется с агрегатными функциями для выполнения операций над группами данных.
* Возвращает одну строку для каждой группы.

## 33.	Что такое нормализация и каковы ее преимущества?
Нормализация — это процесс организации данных в базе данных, Она включает в себя создание таблиц и установление связей между ними в соответствии с правилами, разработанными как для защиты данных, так и для повышения гибкости базы данных, устраняя избыточность и несогласованную зависимость.

Избыточность данных приводит к непродуктивному расходованию свободного места на диске и затрудняет обслуживание баз данных. Например, если данные, хранящиеся в нескольких местах, потребуется изменить, в них придется внести одни и те же изменения во всех этих местах. Изменение адреса клиента проще реализовать, если эти данные хранятся только в таблице Customers и нигде в базе данных.

Что такое «несогласованные зависимости»? Хотя пользователю интуитивно понятно искать в таблице Клиенты адрес конкретного клиента, возможно, не имеет смысла искать там зарплату сотрудника, который обращается к данному клиенту. Зарплата сотрудника связана с сотрудником (зависит от него), поэтому эти сведения следует хранить в таблице Employees (сотрудники). Несогласованные зависимости могут затруднять доступ к данным, так как путь к данным при этом может отсутствовать или быть неправильным.
### Преимущества нормализации:
* Уменьшение избыточности данных: Исключение повторяющихся данных.
* Обеспечение целостности данных: Легкость поддержки и обновления данных.
* Повышение производительности: Улучшение структуры базы данных для выполнения запросов.


## 34.	Какие формы нормализации существуют?
### Первая нормальная форма
* Устраните повторяющиеся группы в отдельных таблицах.
* Создайте отдельную таблицу для каждого набора связанных данных.
* Идентифицируйте каждый набор связанных данных с помощью первичного ключа.

Не используйте несколько полей в одной таблице для хранения похожих данных. Например, для слежения за товаром, который закупается у двух разных поставщиков, можно создать запись с полями, определяющими код первого поставщика и код второго поставщика.

Что произойдет при добавлении третьего поставщика? Добавление поля не является ответом; он требует изменений в программе и таблице и не обеспечивает плавное размещение динамического числа поставщиков. Вместо этого можно поместить все сведения о поставщиках в отдельную таблицу Vendors (поставщики) и связать товары с поставщиками с помощью кодов товаров или поставщиков с товарами с помощью кодов поставщиков.
### Вторая нормальная форма
* Создайте отдельные таблицы для наборов значений, относящихся к нескольким записям.
* Свяжите эти таблицы с помощью внешнего ключа.

Записи не должны зависеть от чего-либо, кроме первичного ключа таблицы (составного ключа, если это необходимо). Возьмем для примера адрес клиента в системе бухгалтерского учета. Этот адрес необходим не только таблице Customers, но и таблицам Orders, Shipping, Invoices, Accounts Receivable и Collections. Вместо того чтобы хранить адрес клиента как отдельный элемент в каждой из этих таблиц, храните его в одном месте: или в таблице Customers, или в отдельной таблице Addresses.
### Третья нормальная форма
* Исключите поля, которые не зависят от ключа.

Значения в записи, которые не являются частью ключа этой записи, не принадлежат в таблице. Если содержимое группы полей может относиться более чем к одной записи в таблице, попробуйте поместить эти поля в отдельную таблицу.

Например, в таблицу Employee Recruitment (наем сотрудников) можно включить адрес кандидата и название университета, в котором он получил образование. Однако для организации групповой почтовой рассылки необходим полный список университетов. Если сведения об университетах будут храниться в таблице Candidates, составить список университетов при отсутствии кандидатов не получится. Таким образом, создайте вместо этого отдельную таблицу Universities и свяжите ее с таблицей Candidates при помощи ключа — кода университета.

ИСКЛЮЧЕНИЕ: Придерживаться третьей нормальной формы, хотя теоретически желательно, не всегда является практическим. Например, для устранения всех возможных зависимостей между полями таблицы Customers придется создать отдельные таблицы для хранения сведений о городах, почтовых индексах, торговых представителях, категориях клиентов и любых других сведений, которые могут дублироваться в нескольких записях. Теоретически нормализация стоит проводить. Однако значительное увеличение числа маленьких таблиц может привести к снижению производительности СУБД или исчерпанию памяти и числа дескрипторов открытых файлов.

Выполнять нормализацию до третьей нормальной формы может быть целесообразно только для часто изменяемых данных. Если при этом сохранятся зависимые поля, спроектируйте приложение так, чтобы при изменении одного из этих полей пользователь должен был проверить все связанные поля.

### Другие формы нормализации
Четвертая нормальная форма, также называемая Boyce-Codd нормальной форме (BCNF), и пятая нормальная форма существуют, но редко рассматриваются в практическом проектировании. Игнорирование этих правил может привести к не совсем идеальному дизайну базы данных, но не должно влиять на функциональные возможности.

## 35.	Что такое денормализация?
Денормализация базы данных — это процесс систематического объединения данных для быстрого получения информации. Этот процесс снижает уровень нормальных форм, что приводит к уменьшению целостности данных.

С другой стороны, производительность извлечения данных увеличивается. Вместо выполнения множества дорогостоящих операций JOIN на многочисленных таблицах, денормализация помогает объединить данные, которые часто или логически взаимосвязаны.
Аномалии базы данных появляются из-за более низких нормальных форм. Проблему избыточности решают путем добавления ограничений на уровне программного обеспечения при вводе данных в базу.
### Почему и когда следует денормализовать базу данных?
* Денормализация базы данных является жизнеспособным методом, когда скорость извлечения данных является важным фактором. Однако этот метод изменяет общую структуру базы данных. Денормализация полезна в следующих сценариях:
* Улучшение производительности запросов. Объединение информации добавляет избыточности. Однако количество операций JOIN уменьшается, что повышает производительность запросов.
* Удобство управления. Нормализованную базу данных сложно управлять из-за высокой гранулярности. Вместо вычисления значений или соединения их по мере необходимости, денормализация помогает предоставить данные, которые уже доступны.
* Ускорение отчетности. Аналитическим данным требуется много вычислений в короткие сроки. Денормализованная база данных для генерации отчетов является отличным решением для быстрого предоставления аналитической информации.

## 36.	Из каких подмножеств состоит SQL?
* DDL (Data Definition Language, или язык описания данных). Их используют, чтобы создавать, изменять и удалять целые таблицы.
* DML (Data Manipulation Language, или язык управления данными). Их применяют к содержимому таблиц, чтобы создавать, изменять, удалять атрибуты и записи. Если нужно получить какую-то информацию из базы данных, то пользуются именно DML-операторами.
* DCL (Data Control Language, или язык контроля данных). Они нужны, чтобы выдавать конкретным пользователям доступ к базам данных и отзывать его.
* TCL (Transaction Control Language, или язык контроля транзакций). Позволяет управлять транзакциями. Транзакция — это набор из нескольких команд, которые выполняются поочерёдно. Если одна из команд внутри транзакции не срабатывает, то все уже совершённые действия отменяются. То есть транзакция может быть совершена либо полностью, либо никак.

## 37.	Какие существуют типы связей в базе данных? Приведите примеры.
### 📌Один к одному (1:1):
* Описание: Каждой записи в одной таблице соответствует одна запись в другой таблице.
* Пример: Таблица person и таблица passport, где у каждого человека только один паспорт, и у каждого паспорта только один владелец.

        CREATE TABLE person (
          person_id INT PRIMARY KEY,
          name VARCHAR(100)
        );
        
        CREATE TABLE passport (
          passport_id INT PRIMARY KEY,
          person_id INT,
          FOREIGN KEY (person_id) REFERENCES person(person_id)
        );
### 📌Один ко многим (1:N):
* Описание: Каждой записи в одной таблице соответствует несколько записей в другой таблице.
* Пример: Таблица department и таблица employees, где один департамент может иметь много сотрудников.

        CREATE TABLE department (
          department_id INT PRIMARY KEY,
          department_name VARCHAR(100)
        );
        
        CREATE TABLE employees (
          employee_id INT PRIMARY KEY,
          first_name VARCHAR(50),
          last_name VARCHAR(50),
          department_id INT,
          FOREIGN KEY (department_id) REFERENCES department(department_id)
        );
### 📌Многие ко многим (M:N):
* Описание: Каждой записи в одной таблице может соответствовать несколько записей в другой таблице, и наоборот. Для реализации такой связи обычно создается промежуточная таблица.
* Пример: Таблицы students, courses и промежуточная таблица enrollments, где один студент может записаться на несколько курсов, и один курс может включать несколько студентов.

        CREATE TABLE students (
          student_id INT PRIMARY KEY,
          student_name VARCHAR(100)
        );
        
        CREATE TABLE courses (
          course_id INT PRIMARY KEY,
          course_name VARCHAR(100)
        );
        
        CREATE TABLE enrollments (
          student_id INT,
          course_id INT,
          PRIMARY KEY (student_id, course_id),
          FOREIGN KEY (student_id) REFERENCES students(student_id),
          FOREIGN KEY (course_id) REFERENCES courses(course_id)
        );
## 38.	Какие ты можешь использовать Числовые типы данных при создании таблици?
Числовые типы данных используются для хранения чисел. Они могут быть целыми или дробными. В SQL существует несколько типов данных для работы с числами, каждый из которых имеет свои особенности и предназначение.
* INT: Целочисленный тип данных. Пример: INT(11). Этот тип данных используется для хранения целых чисел без дробной части. Он подходит для хранения идентификаторов, счетчиков и других целочисленных значений.
* FLOAT: Дробный тип данных с плавающей точкой. Пример: FLOAT(7,4). Этот тип данных используется для хранения чисел с плавающей точкой, которые могут иметь дробную часть. Он подходит для хранения значений, которые требуют высокой точности, но не абсолютной.
* DECIMAL: Точный числовой тип данных с фиксированной точностью. Пример: DECIMAL(10,2). Этот тип данных используется для хранения чисел с фиксированной точностью и масштабом. Он идеально подходит для финансовых данных, где важна точность до последнего знака после запятой.
## 39.	Какие ты можешь использовать Текстовые типы данных при создании таблици?
Строковые типы данных используются для хранения текстовой информации. В зависимости от длины и характера текста, могут использоваться разные типы данных.
* CHAR: Фиксированная длина строки. Пример: CHAR(10). Этот тип данных используется для хранения строк фиксированной длины. Он подходит для хранения данных, длина которых всегда одинакова, например, кодов стран или почтовых индексов.
* VARCHAR: Переменная длина строки. Пример: VARCHAR(255). Этот тип данных используется для хранения строк переменной длины. Он подходит для хранения текстовых данных, длина которых может варьироваться, например, имен пользователей или адресов электронной почты.
* TEXT: Большие текстовые данные. Пример: TEXT. Этот тип данных используется для хранения больших объемов текста. Он подходит для хранения описаний, комментариев и других текстовых данных, длина которых может быть значительной.
## 40.	Какие ты можешь использовать типы данных Даты при создании таблици?
Типы данных даты и времени используются для хранения информации о дате и времени. Они позволяют выполнять операции с датами и временем, такие как вычисление разницы между датами или извлечение отдельных компонентов даты.
* DATE: Хранит дату. Пример: DATE. Этот тип данных используется для хранения дат в формате YYYY-MM-DD. Он подходит для хранения дат рождения, дат создания записей и других данных, связанных с датами.
* TIME: Хранит время. Пример: TIME. Этот тип данных используется для хранения времени в формате HH:MM:SS. Он подходит для хранения времени начала и окончания событий, времени выполнения операций и других данных, связанных с временем.
* DATETIME: Хранит дату и время. Пример: DATETIME. Этот тип данных используется для хранения даты и времени в формате YYYY-MM-DD HH:MM:SS. Он подходит для хранения временных меток, дат и времени событий и других данных, которые требуют точного указания даты и времени.
## 41.	В чем разница между типом данных CHAR и VARCHAR в SQL?
### Длина:
* CHAR: Фиксированная длина, дополнительные пробелы добавляются для заполнения до заданной длины.
* VARCHAR: Переменная длина, память используется эффективно для хранения строки любой длины в пределах заданного размера.
### Использование памяти:
* CHAR: Всегда использует фиксированное количество байтов, вне зависимости от фактической длины данных.
* VARCHAR: Использует память динамически, исходя из фактической длины данных.
### Производительность:
* CHAR: Может быть более эффективным для столбцов с фиксированной длиной, так как операции с фиксированной длиной быстрее.
* VARCHAR: Может быть более эффективным для строк переменной длины, так как уменьшает избыточное использование памяти.

## 42.	Что бы работали джоины нужны ли реляции?
Что бы работали джоины нужны ли реляции
Да, чтобы работать с джоинами (соединениями) в SQL, необходимы реляции между таблицами, поскольку соединения используются для объединения данных из разных таблиц на основе логических связей между ними. Реляции (отношения) определяют, как данные в одной таблице связаны с данными в другой таблице, и это позволяет выполнять операции JOIN для извлечения связанных данных.
